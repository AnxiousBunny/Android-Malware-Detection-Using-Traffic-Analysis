from os import path 
from flask import Flask, request
from flask.json import jsonify
from werkzeug.utils import secure_filename
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn import preprocessing
from sklearn import utils
from scipy import stats
import pickle
from sklearn import preprocessing
from sklearn.model_selection import train_test_split
from sklearn.metrics import f1_score, accuracy_score, plot_confusion_matrix, auc, confusion_matrix
from sklearn.ensemble import RandomForestClassifier
from sklearn.datasets import make_classification
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import classification_report
import statistics
from statistics import mode
import Main





app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = "./pcaps"
app.debug = True


def process(y = "pat"):
    
    Main.main() #calls the extractor
    #Start of the pre-processing phase
    mdf= pd.read_csv('/home/bunny/Desktop/gradproj/serverCode/Malware_Features/dump_1.csv')
    mdfc=mdf.copy()
    mdfc.dropna(inplace=True)
    mdfc.dropna(how ='all')
    mdfc.drop_duplicates(keep=False, inplace=False)
    mdfc.dropna(inplace=True)
    mdfc=mdfc.drop(['Avg_urg_flag'],axis=1)
    mdfc=mdfc.drop(['Avg_rst_flag'],axis=1)
    mdfc=mdfc.drop(['Avg_ICMP_pkt'],axis=1)
    mdfc=mdfc.drop(['Min_pkts_lenght'],axis=1)
    mdfc=mdfc.drop(['Avg_TCP_pkt'],axis=1)
    mdfc=mdfc.drop(['Avg_DNS_over_TCP'],axis=1)
    mdfc=mdfc.drop(['Avg_DNS_pkt'],axis=1)
    mdfc=mdfc.drop(['Avg_UDP_pkt'],axis=1) 
    mdfc=mdfc.drop(['Label'],axis=1) 
    NAN = float("NaN")
    mdfc.replace("", NAN, inplace=True)
    minmax = preprocessing.MinMaxScaler()
    col = mdfc.columns
    minmax_result = minmax.fit_transform(mdfc)
    normalized_mdfc = pd.DataFrame(minmax_result, columns=col)
    normalized_mdfc = pd.get_dummies(normalized_mdfc)
    x=normalized_mdfc
    #End of The Pre-Processing phase
        #load RFC Model
    final_model = pickle.load(open("RFC_MODEL.pkl", "rb"))
#Predict
    predicted_lsit=final_model.predict(x)
#convert list to np.array (easier to deal with calc)
    predicted_lsit=np.array(predicted_lsit)
    print(predicted_lsit)


# In[12]:


#Calculation of the most value repeated in the predicted list


#print previous calc
    print('most redundant value in RFC pred = ', mode(predicted_lsit))
    RFC_label = mode(predicted_lsit)

    ones = 0
    zeros = 0
#counting malware and benign packets
    for i in predicted_lsit:
        if i == 1:
            ones = ones + 1
        if i == 0:
            zeros = zeros + 1
        
        

    print('n_malware_pred = ', zeros)
    print('n_benign_pred = ', ones)

    sum = ones + zeros

    print('n_list = ', sum)
#percentage of malware and benign in predicted list
    malware_percentage = float( zeros / sum ) * 100
    benign_percentage = float( ones / sum ) * 100

    print('malware percentage = ', malware_percentage)
    print('benign percentage = ', benign_percentage)

#PREDICTION RESULT
    if malware_percentage < benign_percentage :
        print('RFC_PREDICTION = Benign')
    if malware_percentage == benign_percentage :
        print('RFC_PREDICTION = Not sure')
    if malware_percentage > benign_percentage :
        print('RFC_PREDICTION = Malware')
    
    Not_sure = 0
    if malware_percentage == benign_percentage :
        Not_sure = Not_sure+10


# In[13]:


    final_model = pickle.load(open("DT_MODEL.pkl", "rb"))
    predicted_lsit=final_model.predict(x)
    print(predicted_lsit)


# In[14]:


#Calculation of the most value repeated in the predicted list

#print previous calc
    print('most redundant value in DTC pred = ', mode(predicted_lsit))
    DTC_label = mode(predicted_lsit)

    ones = 0
    zeros = 0

#counting malware and benign packets
    for i in predicted_lsit:
        if i == 1:
            ones = ones + 1
        if i == 0:
            zeros = zeros + 1

    print('n_malware_pred = ', zeros)
    print('n_benign_pred = ', ones)

    sum = ones + zeros

    print('n_list = ', sum)

    #percentage of malware and benign in predicted list
    malware_percentage = float( zeros / sum ) * 100
    benign_percentage = float( ones / sum ) * 100

    print('malware percentage = ', malware_percentage)
    print('benign percentage = ', benign_percentage)

    #PREDICTION RESULT
    if malware_percentage < benign_percentage :
        print('DTC_PREDICTION = Benign')
    if malware_percentage == benign_percentage :
        print('DTC_PREDICTION = Not sure')   
    if malware_percentage > benign_percentage :
        print('DTC_PREDICTION = Malware')

        
    if malware_percentage == benign_percentage :
        Not_sure = Not_sure+10


    # In[15]:


    final_model = pickle.load(open("KN_MODEL.pkl", "rb"))
    predicted_lsit=final_model.predict(x)
    print(predicted_lsit)


    # In[16]:


    #Calculation of the most value repeated in the predicted list

    #print previous calc
    print('most redundant value in KN pred = ', mode(predicted_lsit))
    KN_label = mode(predicted_lsit)

    ones = 0
    zeros = 0

    #counting malware and benign packets
    for i in predicted_lsit:
        if i == 1:
            ones = ones + 1
        if i == s0:
            zeros = zeros + 1

    print('n_malware_pred = ', zeros)
    print('n_benign_pred = ', ones)

    sum = ones + zeros

    print('n_list = ', sum)

    #percentage of malware and benign in predicted list
    malware_percentage = float( zeros / sum ) * 100
    benign_percentage = float( ones / sum ) * 100

    print('malware percentage = ', malware_percentage)
    print('benign percentage = ', benign_percentage)

    #PREDICTION RESULT
    if malware_percentage < benign_percentage :
        print('KN_PREDICTION = Benign')   
    if malware_percentage == benign_percentage :
        print('KN_PREDICTION = Not sure')   
    if malware_percentage > benign_percentage :
        print('KN_PREDICTION = Malware')



    # In[17]:



    label_sum = RFC_label + DTC_label + KN_label
    if label_sum >= 2:
        return "VOTING_RESULT = Benign"
    if label_sum < 2:
        return "VOTING_RESULT = Malware"

    
    
    
    
    
@app.route('/', methods = ['POST'])
def main():
    pcap = request.files['pcap']
    pcap.save(path.join(app.config['UPLOAD_FOLDER'], secure_filename(pcap.filename)))
    
    result = process("path to pcap file")

    return f'{result}\n\r'

if __name__ == '__main__':
   app.run()
